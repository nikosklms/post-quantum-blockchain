#[cfg(test)]
mod tests {
    use crate::blockchain::Blockchain;
    use crate::transaction::{Transaction, TxOutput};
    use crate::wallet::Wallet;
    use std::fs;

    #[test]
    fn test_negative_amount_exploit() {
        let filename = "test_exploit_neg.json";
        let _ = fs::remove_file(filename);
        let mut bc = Blockchain::new(filename);
        let alice = Wallet::new();
        let bob = Wallet::new();

        // Fund Alice
        let coinbase = Transaction::new_coinbase(&alice.get_public_key(), 1);
        bc.add_block(vec![coinbase]);

        // Alice tries to print money: Input 50 -> Output 100 to Bob, -50 to Alice
        // Sum = 50. Logic "Input >= Output" (50 >= 50) Passes.
        let (inputs, _) = bc.find_spendable_outputs(&alice.get_public_key(), 50.0);
        let mut tx = Transaction::new(inputs, &bob.get_public_key(), 100.0, &alice);
        
        // Manual tamper to add negative output
        tx.outputs.push(TxOutput {
            amount: -50.0,
            recipient: alice.get_public_key(),
        });
        
        // Re-sign because we tampered
        tx.id = tx.calculate_hash();
        for i in 0..tx.inputs.len() {
            tx.inputs[i].signature = alice.sign(tx.id.as_bytes());
        }

        // This SHOULD fail, but likely passes currently
        let accepted = bc.add_to_mempool(tx);
        
        // Using assert check to confirm if it failed (we want it to fail)
        // If accepted is true, we have a bug.
        println!("Negative amount transaction accepted? {}", accepted);
        assert!(!accepted, "VULNERABILITY: Negative amount transaction was accepted!");
        
        let _ = fs::remove_file(filename);
    }

    #[test]
    fn test_nan_exploit() {
        let filename = "test_exploit_nan.json";
        let _ = fs::remove_file(filename);
        let mut bc = Blockchain::new(filename);
        let alice = Wallet::new();
        let bob = Wallet::new();

        let coinbase = Transaction::new_coinbase(&alice.get_public_key(), 1);
        bc.add_block(vec![coinbase]);

        let (inputs, _) = bc.find_spendable_outputs(&alice.get_public_key(), 50.0);
        
        // Create TX with NaN amount
        let mut tx = Transaction::new(inputs, &bob.get_public_key(), 50.0, &alice);
        tx.outputs[0].amount = f64::NAN;
        
        tx.id = tx.calculate_hash();
        for i in 0..tx.inputs.len() {
            tx.inputs[i].signature = alice.sign(tx.id.as_bytes());
        }

        let accepted = bc.add_to_mempool(tx);
        println!("NaN transaction accepted? {}", accepted);
        assert!(!accepted, "VULNERABILITY: NaN transaction was accepted!");

        let _ = fs::remove_file(filename);
    }
}
